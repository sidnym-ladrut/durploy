#!/bin/sh

# TODO: Add support for multiple ships to be synchronize targets for desk
# in a single command.
# TODO: Handle cases when 'urbit' is not installed on the host system
# (allow users to download the latest binary for their system, managed
# by the local config in e.g. ~/.local/share/durploy/binaries)
# TODO: Enable optional interactivity for destructive operations (e.g. the
# dest dir already exists; want to clear it out? etc.)
# TODO: Improve cliarg parsing by allowing for '--' delimiters between
# flag args and positional args for each command
# FIXME: Pass top-level configuration instead of using global-esque variables
# (e.g. for all "$durploy_command_*" variables).

## Constants ##

DURPLOY_VERSION="0.0.5"
DURPLOY_HELP_FOOTER="
Report bugs to: ~sidnym-ladrut
durploy home page: <https://github.com/sidnym-ladrut/durploy>"
DURPLOY_HELP_BASE="usage: durploy [-v | --version] [-h | --help]
               [-b | --bin <bin-path>] [-c | --cwd]
               <command> [<args>]
d(e)ploy ur(bit) ships and desks

Command options:
  ship: Generate and run Urbit ships
  desk: Deploy desk files to running Urbit ships

Flag arguments:
  -v, --version: Show the software version
  -h, --help: Show this help message

  -b, --bin: Set the Urbit binary to be used for deploying ships/desks
    (default: \$DURPLOY_URBIT_BIN)
  -c, --cwd: Set ship paths to be relative to the current working directory
    (default: relative to \$DURPLOY_SHIP_DIR)

Config options (via environment variables or config file):
  DURPLOY_CONFIG_FILE: Path to the config file (default: \$XDG_CONFIG_HOME/durploy/durployrc)
  DURPLOY_SHIP_DIR: Path for storing ship piers (default: \$XDG_CACHE_HOME/durploy/ships)
  DURPLOY_BACKUP_DIR: Path for storing ship backups (default: \$XDG_CACHE_HOME/durploy/backups)
  DURPLOY_URBIT_BIN: Path to default Urbit binary (default: \$(which urbit))
$DURPLOY_HELP_FOOTER"
DURPLOY_HELP_SHIP="usage: durploy ship [-u | --uid <ship-uid>]
                      <ship-path> [<boot-script> ...]
Generate and run Urbit ships (w/ optional boot script(s))

Positional arguments:
  ship-path: The relative file path for the ship's pier (e.g. testing/zod)
  boot-script: The file path for the boot script (e.g. /path/to/init.sh)

Flag arguments:
  -u, --uid: The Urbit ID of the ship to be deployed at the given path
    (default: zod)
$DURPLOY_HELP_FOOTER"
DURPLOY_HELP_DESK="usage: durploy desk [-w | --watch] [-r | --reset-strategy <strategy>]
                    <ship-path> <desk-name> <desk-path>
Deploy desk files to running Urbit ships

Positional arguments:
  ship-path: The relative file path for the ship's pier (e.g. testing/zod)
  desk-name: The name of the desk to deploy (e.g. my-desk)
  desk-path: The file path for the desk's source files (e.g. /path/to/my-desk)

Flag arguments:
  -w, --watch: Monitor <desk-path> for changes and deploy continuously
  -r, --reset-strategy: Strategy for resetting apps on a desk; one of:
    always: reset apps every time a file is changed
    appsur: only reset apps when their particular app/sur file changes
    sur: only reset apps when their particular sur file changes
    never (default): never reset apps; only copy files and '|commit'
$DURPLOY_HELP_FOOTER"
DURPLOY_RESET_STRATS="always appsur sur never"
# shellcheck disable=SC2059,SC2086
DURPLOY_RESET_STRATS_REGEX=$(printf "(%s)|" $DURPLOY_RESET_STRATS \
	| sed 's/|$//' \
	| xargs printf "^(%s)$"
)

## Config Variables ##

_durploy__info() { echo "[INFO]: $1" && exit 1; }
_durploy__error() { echo "[ERROR]: $1" && exit 1; }
_durploy__invalid_pargs_exact() { [ "$(($1+1))" != "$#" ]; }
_durploy__invalid_pargs_atleast() { [ "$(($1+1))" -gt "$#" ]; }

DURPLOY_CONFIG_FILE="${DURPLOY_CONFIG_FILE:-${XDG_CONFIG_HOME:-~/.config}/durploy/durployrc}"
# shellcheck disable=SC1090
[ -f "$DURPLOY_CONFIG_FILE" ] && . "$DURPLOY_CONFIG_FILE"

DURPLOY_SHIP_DIR="${DURPLOY_SHIP_DIR:-${XDG_CACHE_HOME:-~/.cache}/durploy/ships}"
DURPLOY_BACKUP_DIR="${DURPLOY_BACKUP_DIR:-${XDG_CACHE_HOME:-~/.cache}/durploy/backups}"
DURPLOY_CACHE_DIR="${DURPLOY_CACHE_DIR:-${XDG_CACHE_HOME:-~/.cache}/durploy/cache}"
DURPLOY_URBIT_BIN="${DURPLOY_URBIT_BIN:-$(which urbit)}"

for _durploy_dir in "$DURPLOY_SHIP_DIR" "$DURPLOY_BACKUP_DIR" "$DURPLOY_CACHE_DIR"; do
	if [ ! -d "$_durploy_dir" ]; then
		mkdir -p "$_durploy_dir" || \
			_durploy__error "couldn't create config directory at path '$_durploy_dir'"
	fi
done
[ ! -x "$DURPLOY_URBIT_BIN" ] && \
	_durploy__error "couldn't find default vere binary at path '$DURPLOY_URBIT_BIN'"

## Helper Functions ##

_durploy__invalid_ship() {
	echo "(scan \"$1\" fed:ag)" | "$durploy_command_binary" eval 2>&1 | grep -q "bail: %exit"
}
_durploy__invalid_desk() {
	echo "(scan \"$1\" sym)" | "$durploy_command_binary" eval 2>&1 | grep -q "bail: %exit"
}

_durploy__send_dojo() {
	_durploy_senddojo_pier=$1
	_durploy_senddojo_cmddojo=$2
	_durploy_senddojo_cmdapp=$3

	_durploy_senddojo_shipport=$(awk '/loopback/ {print $1;}' < "$_durploy_senddojo_pier/.http.ports")
	_durploy_senddojo_cmdsource="{\"dojo\":\"$_durploy_senddojo_cmddojo\"}"
	if [ -z "$_durploy_senddojo_cmdapp" ] ; then
		_durploy_senddojo_cmdsink="{\"stdout\":null}"
	else
		_durploy_senddojo_cmdsink="{\"app\":\"$_durploy_senddojo_cmdapp\"}"
	fi

	curl -s --data \
		"{\"source\":$_durploy_senddojo_cmdsource,\"sink\":$_durploy_senddojo_cmdsink}" \
		"http://127.0.0.1:$_durploy_senddojo_shipport" \
		| xargs printf %s | sed 's/\\n/\n/g'
}
_durploy__send_hood() {
	_durploy__send_dojo "$1" "$(echo "$2" | sed 's/^|/+hood\//')" "hood"
}

_durploy__check_ship_live() {
	pgrep -f "$durploy_command_binary serf $(readlink -f "$1")" | grep -q -v "grep"
}

_durploy__grab_ship_uid() {
	_durploy_grabuid_path=$1

	if _durploy__check_ship_live "$_durploy_grabuid_path"; then
		_durploy_grabuid_live="true"
	else
		_durploy_grabuid_live="false"
	fi

	[ "$_durploy_grabuid_live" = "false" ] && \
		"$durploy_command_binary" -d -L "$_durploy_grabuid_path" >/dev/null 2>&1
	_durploy_grabuid_suid="$(_durploy__send_dojo "$_durploy_grabuid_path" "our")"
	[ "$_durploy_grabuid_live" = "false" ] && \
		kill -9 "$(pgrep -f "$durploy_command_binary serf $(readlink -f "$_durploy_grabuid_path")")" >/dev/null 2>&1

	echo "$_durploy_grabuid_suid" | sed 's/^~//'
}

_durploy__check_desk_path() {
	_durploy_checkdp_path=$1
	_durploy_checkdp_uid=$2

	_durploy__invalid_ship "$_durploy_checkdp_uid" \
		&& _durploy__error "invalid ship name '$_durploy_checkdp_uid'"
	if [ ! -e "$_durploy_checkdp_path" ]; then
		mkdir -p "$(dirname "$_durploy_checkdp_path")" \
			|| _durploy__error "couldn't create directory at path '$_durploy_checkdp_path'"
	elif [ ! -d "$_durploy_checkdp_path" ]; then
		_durploy__error "invalid artifact exists at path '$_durploy_checkdp_path'"
	else
		_durploy_checkdp_rid="$(_durploy__grab_ship_uid "$_durploy_checkdp_path")"
		if [ "$_durploy_checkdp_rid" != "$_durploy_checkdp_uid" ]; then
			_durploy__error "invalid pier for '$_durploy_checkdp_uid' at '$_durploy_checkdp_path' (pier @p: '$_durploy_checkdp_rid')"
		fi
	fi
}

# ====> cp -r pkg/arvo/ squad/mar/
# ====> cp -r pkg/arvo/ squad/lib/ # this is for debug files
#
# ====> git clone git@github.com:urbit/urbit.git
# ====> cd urbit
# ====> git checkout $(git describe --tags $(git rev-list --tags --max-count=1))
# ====> cp -r pkg/arvo/mar/{bill*,hoon*,json*,kelvin*,mime*,noun*,ship*,txt*} squad/mar/
# ====> cp -r pkg/arvo/lib/{agentio*,dbug*,default-agent*,skeleton*} squad/lib/ # this is for debug files
# ====> cd ..
# ====> git clone git@github.com:tloncorp/landscape.git
# ====> cd landscape
# ====> git checkout $(git describe --tags $(git rev-list --tags --max-count=1))
# ====> cp -r # TODO: all docket files

_durploy__desk_init() {
	_durploy_init_desk=$1
	_durploy_init_pier="$(readlink -f "$2")"
	_durploy__send_hood "$_durploy_init_pier" "|new-desk %$_durploy_init_desk, =hard &"
	_durploy__send_hood "$_durploy_init_pier" "|mount %$_durploy_init_desk"
}
_durploy__desk_cdir() {
	_durploy_copydir_desk=$1
	_durploy_copydir_pier="$(readlink -f "$2")"
	_durploy_copydir_from="$(readlink -f "$3")"
	rsync -rcuL "$_durploy_copydir_from/" "$_durploy_copydir_pier/$_durploy_copydir_desk/"
}
_durploy__desk_cgit() {
	_durploy_copygit_desk=$1
	_durploy_copygit_pier="$(readlink -f "$2")"
	_durploy_copygit_repo=$3
	_durploy_copygit_hash=$4
	_durploy_copygit_from=$5
	_durploy_copygit_dest=$6

	_durploy_copygit_repopath="$DURPLOY_CACHE_DIR/$(echo "$_durploy_copygit_repo" | sed -re 's|.*/(.+)\.git|\1|g')"
	_durploy_copygit_frompath="$_durploy_copygit_repopath/$_durploy_copygit_from"
	_durploy_copygit_destpath="$_durploy_copygit_pier/$_durploy_copygit_desk/$_durploy_copygit_dest"

	if [ ! -d "$_durploy_copygit_repopath" ]; then
		git clone "$_durploy_copygit_repo" "$_durploy_copygit_repopath"
	else
		# TODO: Verify that this is a git repository with the proper remote, i.e. "$_durploy_copygit_repo"
		:
	fi

	if [ ! -z "$_durploy_copygit_hash" ]; then
		# TODO: Checkout the specified version
		# git -C "$_durploy_copygit_repopath" checkout $(git describe --tags $(git rev-list --tags --max-count=1))
		:
	fi

	rsync -rcuL "$_durploy_copygit_frompath" "$_durploy_copygit_destpath"
}
_durploy__desk_wrap() {
	_durploy_wrap_desk=$1
	_durploy_wrap_pier="$(readlink -f "$2")"
	_durploy__send_hood "$_durploy_wrap_pier" "|commit %$_durploy_wrap_desk"
	_durploy__send_hood "$_durploy_wrap_pier" "|install our %$_durploy_wrap_desk"
}

_durploy__desk_install() {
	_durploy_install_desk=$1
	_durploy_install_pier="$(readlink -f "$2")"
	_durploy_install_from="$(readlink -f "$3")"

	_durploy__desk_init "$_durploy_install_desk" "$_durploy_install_pier"
	_durploy__desk_cdir "$_durploy_install_from" "$_durploy_install_pier" "$_durploy_install_from"
	_durploy__desk_wrap "$_durploy_install_desk" "$_durploy_install_pier"
}

_durploy__desk_sync() {
	_durploy_sync_desk=$1
	_durploy_sync_pier="$(readlink -f "$2")"
	_durploy_sync_from="$(readlink -f "$3")"
	_durploy_sync_rstrat=$4

	_durploy_sync_files=$(rsync -in -rcuL "$_durploy_sync_from/" "$_durploy_sync_pier/$_durploy_sync_desk/" \
		| awk '{if ($0 == "") exit; else print $2;}'
	)
	# TODO: Read the content of `desk.bill`?
	_durploy_sync_srcapps=$(find -L "$_durploy_sync_from/app" -type f -name "*.hoon" \
		| sed -re 's?.*/([^/]+).hoon$?\1?g'
	)
	_durploy_sync_apps=$(echo "$_durploy_sync_files" \
		| grep -E '^app/.+' \
		| sed -re 's?.*/([^/]+).hoon$?\1?g'
	)
	_durploy_sync_surs=$(echo "$_durploy_sync_files" \
		| grep -E '^sur/.+' \
		| sed -re 's?.*/([^/]+).hoon$?\1?g'
	)

	if [ -n "$_durploy_sync_files" ]; then
		rsync -rcuL "$_durploy_sync_from/" "$_durploy_sync_pier/$_durploy_sync_desk/"

		_durploy_sync_reloadapps=""
		for _durploy_sync_app in $_durploy_sync_srcapps; do
			_durploy_sync_doreload="false"
			case $_durploy_sync_rstrat in
				always) _durploy_sync_doreload="true" ;;
				appsur) echo "$_durploy_sync_apps $_durploy_sync_surs" \
					| grep -F -wq "$_durploy_sync_app" \
					&& _durploy_sync_doreload="true" ;;
				sur) echo "$_durploy_sync_surs" \
					| grep -F -wq "$_durploy_sync_app" \
					&& _durploy_sync_doreload="true" ;;
				never) _durploy_sync_doreload="false" ;;
			esac
			if [ "$_durploy_sync_doreload" = "true" ]; then
				_durploy_sync_reloadapps="$_durploy_sync_reloadapps $_durploy_sync_app"
			fi
		done

		for _durploy_sync_reloadapp in $_durploy_sync_reloadapps; do
			_durploy__send_hood "$_durploy_sync_pier" "|nuke %$_durploy_sync_reloadapp, =hard &"
		done
		_durploy__send_hood "$_durploy_sync_pier" "|commit %$_durploy_sync_desk"
		for _durploy_sync_reloadapp in $_durploy_sync_reloadapps; do
			_durploy__send_hood "$_durploy_sync_pier" "|revive %$_durploy_sync_reloadapp"
		done
	fi
}

_durploy__hash_config() {
	_durploy_hashconf_bin=$(sha256sum -b "$durploy_command_binary" | awk '{print $1;}')
	_durploy_hashconf_cfg=$(echo "test" | sha256sum | awk '{print $1;}')
	_durploy_hashconf_fin=$(echo "$_durploy_hashconf_bin" "$_durploy_hashconf_cfg" | sha256sum | awk '{print $1;}')
	printf "%s-%s" "$1" "$_durploy_hashconf_fin"
}

## Sub-Commands ##

durploy__ship() {
	while : ; do case $1 in
		-h | --help) printf "%s\\n" "$DURPLOY_HELP_SHIP" && exit 1 ;;
		-u | --uid) durploy_ship_uid=$2 && shift 2 ;;
		-*) printf "invalid option: %s\\n" "$1" && exit 1 ;;
		*) break ;;
	esac done
	_durploy__invalid_pargs_atleast 1 "$@" && _durploy__info "$DURPLOY_HELP_SHIP"

	durploy_ship_base=$1; shift
	[ -z "$durploy_ship_uid" ] && durploy_ship_uid="zod"

	for _durploy_ship_script in "$@"; do
		# TODO: Substitute in common replacements, e.g. @app-files, @debug-files
		_durploy_ship_scriptpath="$(readlink -f "$_durploy_ship_script")"
		[ ! -f "$_durploy_ship_scriptpath" ] && \
			_durploy__error "provided init script either doesn't exist or can't be run: '$_durploy_ship_script'"
	done

	if [ "$durploy_command_usecwd" = "true" ]; then
		durploy_ship_pier="$(cwd)/$durploy_ship_base"
	else
		durploy_ship_pier="$DURPLOY_SHIP_DIR/$durploy_ship_base"
	fi
	durploy_bkup_path="$DURPLOY_BACKUP_DIR/$(_durploy__hash_config "$durploy_ship_uid")"

	if _durploy__check_ship_live "$durploy_ship_pier"; then
		_durploy__info "urbit ship '$durploy_ship_base' is already running"
	else
		_durploy__check_desk_path "$durploy_ship_pier" "$durploy_ship_uid"
		_durploy__check_desk_path "$durploy_bkup_path" "$durploy_ship_uid"

		# if the pier doesn't exist yet, try to create it
		if [ ! -e "$durploy_ship_pier" ]; then
			# if the backup exists and is valid, then copy it to the new pier path
			if [ -d "$durploy_bkup_path" ] && "$durploy_command_binary" -t -x -L "$durploy_bkup_path"; then
				cp -r "$durploy_bkup_path" "$durploy_ship_pier"
			# otherwise, attempt to create a new pier for the ship
			elif ! "$durploy_command_binary" -t -x -L -c "$durploy_ship_pier" -F "$durploy_ship_uid"; then
				_durploy__error "couldn't create ship '$durploy_ship_uid' at '$durploy_ship_pier'"
			fi
		# else, attempt to boot the urbit and immediately exit
		else
			if ! "$durploy_command_binary" -t -x -L "$durploy_ship_pier"; then
				_durploy__error "couldn't revive ship '$durploy_ship_uid' at '$durploy_ship_pier'"
			fi
		fi

		# if the backup doesn't exist, copy the new pier into that path
		if [ -n "$durploy_bkup_path" ] && [ ! -e "$durploy_bkup_path" ]; then
			cp -r "$durploy_ship_pier" "$durploy_bkup_path"
		elif [ "0" != "$#" ]; then
			"$durploy_command_binary" -d -L "$durploy_ship_pier" >/dev/null 2>&1
			for _durploy_ship_script in "$@"; do
				# shellcheck disable=SC1090
				. "$(readlink -f "$_durploy_ship_script")"
			done
			kill -9 "$(pgrep -f "$durploy_command_binary serf $(readlink -f "$durploy_ship_pier")")" >/dev/null 2>&1
		fi

		"$durploy_command_binary" -L "$durploy_ship_pier"
	fi
}

durploy__desk() {
	while : ; do case $1 in
		-h | --help) printf "%s\\n" "$DURPLOY_HELP_DESK" && exit 1 ;;
		-w | --watch) durploy_desk_iswatching="true" && shift 1 ;;
		-r | --reset-strategy) durploy_desk_resetstrat=$2 && shift 2 ;;
		-*) printf "invalid option: %s\\n" "$1" && exit 1 ;;
		*) break ;;
	esac done
	_durploy__invalid_pargs_atleast 3 "$@" && _durploy__info "$DURPLOY_HELP_DESK"

	durploy_desk_shipbase=$1; shift
	durploy_desk_name=$1; shift
	durploy_desk_codepath=$1; shift
	[ -z "$durploy_desk_iswatching" ] && durploy_desk_iswatching="false"
	[ -z "$durploy_desk_resetstrat" ] && durploy_desk_resetstrat="never"

	if [ "$durploy_command_usecwd" = "true" ]; then
		durploy_desk_pier="$(cwd)/$durploy_desk_shipbase"
	else
		durploy_desk_pier="$DURPLOY_SHIP_DIR/$durploy_desk_shipbase"
	fi

	_durploy__invalid_desk "$durploy_desk_name" \
		&& _durploy__error "invalid desk name '$durploy_desk_name'"
	[ ! -d "$durploy_desk_codepath" ] \
		&& _durploy__error "invalid urbit code desk at '$durploy_desk_codepath'"
	[ ! -d "$durploy_desk_pier" ] \
		&& _durploy__error "invalid urbit pier at '$durploy_desk_pier'"
	! echo "$durploy_desk_resetstrat" | grep -q -E "$DURPLOY_RESET_STRATS_REGEX" \
		&& _durploy__error "invalid reset strategy '$durploy_desk_resetstrat'; try one of '$DURPLOY_RESET_STRATS'"

	if ! _durploy__check_ship_live "$durploy_desk_pier"; then
		_durploy__error "must run ship to deploy desk; please run: durploy ship $durploy_desk_shipbase"
	fi

	if [ ! -d "$durploy_desk_pier/$durploy_desk_name" ]; then
		_durploy__desk_install \
			"$durploy_desk_name" \
			"$durploy_desk_pier" \
			"$durploy_desk_codepath"
	fi

	while : ; do
		_durploy__desk_sync \
			"$durploy_desk_name" \
			"$durploy_desk_pier" \
			"$durploy_desk_codepath" \
			"$durploy_desk_resetstrat"
		[ "$durploy_desk_iswatching" = "false" ] && break
		sleep 2
	done
}

## Main Command ##

durploy() {
	while : ; do case $1 in
		-h | --help) printf "%s\\n" "$DURPLOY_HELP_BASE" && exit 1 ;;
		-v | --version) printf "%s\\n" "$DURPLOY_VERSION" && exit 1 ;;
		-b | --bin) durploy_command_binary=$2 && shift 2 ;;
		-c | --cwd) durploy_command_usecwd="true" && shift 1 ;;
		-*) printf "invalid option: %s\\n" "$1" && exit 1 ;;
		*) break ;;
	esac done
	_durploy__invalid_pargs_atleast 1 "$@" && _durploy__info "$DURPLOY_HELP_BASE"

	durploy_command_name=$1; shift
	[ -z "$durploy_command_binary" ] && durploy_command_binary="$DURPLOY_URBIT_BIN"
	[ -z "$durploy_command_usecwd" ] && durploy_command_usecwd="false"
	durploy_command_binary="$(readlink -f "$durploy_command_binary")"

	if type "durploy__$durploy_command_name" >/dev/null 2>&1; then
		"durploy__$durploy_command_name" "$@"
	else
		_durploy__error "invalid command name '$durploy_command_name'"
	fi
}

# if the functions above are sourced into an interactive interpreter, the user can
# just call "durploy ship" or "durploy desk" with no further code needed.

# if invoked as a script rather than sourced, call function named on argv via the below;
# note that this must be the first operation other than a function definition
# for $_ to successfully distinguish between sourcing and invocation:
# [ ! "$_" -eq "$0" ] && return

durploy "$@"
