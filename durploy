#!/bin/sh

# TODO: Add support for multiple ships to be synchronize targets for desk
# in a single command.
# TODO: Handle cases when 'urbit' is not installed on the host system
# (allow users to download the latest binary for their system, managed
# by the local config in e.g. ~/.local/share/durploy/binaries)
# TODO: Handle top-level cases for different Urbit binary versions
# TODO: Enable optional interactivity for destructive operations (e.g. the
# dest dir already exists; want to clear it out? etc.)
# TODO: Add support for different binary versions and builds (hash of the
# version information?)
# > ~/.local/share/durploy/versions/urbit-2.9
# > ~/.local/share/durploy/backups/zod-2.9
# TODO: Improve cliarg parsing by allowing for '--' delimiters between
# flag args and positional args for each command

## Constants ##

DURPLOY_VERSION="0.0.5"
DURPLOY_HELP_FOOTER="
Report bugs to: ~sidnym-ladrut
durploy home page: <https://github.com/sidnym-ladrut/durploy>"
DURPLOY_HELP_BASE="usage: durploy [-v | --version] [-h | --help] [-c | --cwd] <command> [<args>]
d(e)ploy ur(bit) ships and desks

Command options:
  ship: Generate and run Urbit ships
  desk: Deploy desk files to running Urbit ships

Config options (via environment variables or config file):
  DURPLOY_CONFIG_FILE: Path to the config file (default: \$XDG_CONFIG_HOME/durploy/durployrc)
  DURPLOY_SHIP_DIR: Path for storing ship piers (default: \$XDG_CACHE_HOME/durploy/ships)
  DURPLOY_BACKUP_DIR: Path for storing ship backups (default: \$XDG_CACHE_HOME/durploy/backups)
  DURPLOY_URBIT_BIN: Path to default Urbit binary (default: \$(which urbit))

Flag arguments:
  -v, --version: Show the software version
  -h, --help: Show this help message

  -c, --cwd: Set ship paths to be relative to the current working directory
    (default: relative to \$DURPLOY_SHIP_DIR)
$DURPLOY_HELP_FOOTER"
DURPLOY_HELP_SHIP="usage: durploy ship [-u | --uid <ship-uid>] <ship-path>
Generate and run Urbit ships

Positional arguments:
  ship-path: The relative file path for the ship's pier (e.g. testing/zod)

Flag arguments:
  -u, --uid: The Urbit ID of the ship to be deployed at the given path
    (default: zod)
$DURPLOY_HELP_FOOTER"
DURPLOY_HELP_DESK="usage: durploy desk [-w | --watch] [-r | --reset-strategy]
                     <desk> <desk-path> <ship-path>
Deploy desk files to running Urbit ships

Positional arguments:
  desk: The name of the desk to deploy (e.g. my-desk)
  desk-path: The file path for the desk's source files (e.g. /path/to/my-desk)
  ship-path: The relative file path for the ship's pier (e.g. testing/zod)

Flag arguments:
  -w, --watch: Monitor <desk-path> for changes and deploy continuously
  -r, --reset-strategy: Strategy for resetting apps on a desk; one of:
    always: reset apps every time a file is changed
    appsur: only reset apps when their particular app/sur file changes
    sur: only reset apps when their particular sur file changes
    never (default): never reset apps; only copy files and '|commit'
$DURPLOY_HELP_FOOTER"
DURPLOY_RESET_STRATS="always appsur sur never"
# shellcheck disable=SC2059,SC2086
DURPLOY_RESET_STRATS_REGEX=$(printf "(%s)|" $DURPLOY_RESET_STRATS \
	| sed 's/|$//' \
	| xargs printf "^(%s)$"
)

## Config Variables ##

_durploy__info() { echo "[INFO]: $1" && exit 1; }
_durploy__error() { echo "[ERROR]: $1" && exit 1; }
_durploy__invalid_pargs_exact() { [ "$(($1+1))" != "$#" ]; }
_durploy__invalid_pargs_atleast() { [ "$(($1+1))" -gt "$#" ]; }

DURPLOY_CONFIG_FILE="${DURPLOY_CONFIG_FILE:-${XDG_CONFIG_HOME:-~/.config}/durploy/durployrc}"
# shellcheck disable=SC1090
[ -f "$DURPLOY_CONFIG_FILE" ] && . "$DURPLOY_CONFIG_FILE"

DURPLOY_SHIP_DIR="${DURPLOY_SHIP_DIR:-${XDG_CACHE_HOME:-~/.cache}/durploy/ships}"
DURPLOY_BACKUP_DIR="${DURPLOY_BACKUP_DIR:-${XDG_CACHE_HOME:-~/.cache}/durploy/backups}"
# FIXME: May need to change 'pgrep' checks if the given default binary name is different
DURPLOY_URBIT_BIN="${DURPLOY_URBIT_BIN:-$(which urbit)}"

if [ ! -d "$DURPLOY_SHIP_DIR" ]; then
	mkdir -p "$DURPLOY_SHIP_DIR" \
		|| _durploy__error "couldn't create default ship directory at path '$DURPLOY_SHIP_DIR'"
fi
if [ ! -d "$DURPLOY_BACKUP_DIR" ]; then
	mkdir -p "$DURPLOY_BACKUP_DIR" \
		|| _durploy__error "couldn't create default backup directory at path '$DURPLOY_BACKUP_DIR'"
fi
[ ! -x "$DURPLOY_BACKUP_DIR" ] && \
	_durploy__error "couldn't find default vere binary at path '$DURPLOY_URBIT_BIN'"

## Helper Functions ##

_durploy__invalid_ship() {
	echo "(scan \"$1\" fed:ag)" | "$DURPLOY_URBIT_BIN" eval 2>&1 | grep -q "bail: %exit"
}
_durploy__invalid_desk() {
	echo "(scan \"$1\" sym)" | "$DURPLOY_URBIT_BIN" eval 2>&1 | grep -q "bail: %exit"
}

_durploy__send_dojo() {
	_durploy_senddojo_shippath=$1
	_durploy_senddojo_cmddojo=$2
	_durploy_senddojo_cmdapp=$3

	_durploy_senddojo_shipport=$(awk '/loopback/ {print $1;}' < "$_durploy_senddojo_shippath/.http.ports")
	_durploy_senddojo_cmdsource="{\"dojo\":\"$_durploy_senddojo_cmddojo\"}"
	if [ -z "$_durploy_senddojo_cmdapp" ] ; then
		_durploy_senddojo_cmdsink="{\"stdout\":null}"
	else
		_durploy_senddojo_cmdsink="{\"app\":\"$_durploy_senddojo_cmdapp\"}"
	fi

	curl -s --data \
		"{\"source\":$_durploy_senddojo_cmdsource,\"sink\":$_durploy_senddojo_cmdsink}" \
		"http://127.0.0.1:$_durploy_senddojo_shipport" \
		| xargs printf %s | sed 's/\\n/\n/g'
}
_durploy__send_hood() {
	_durploy__send_dojo "$1" "$(echo "$2" | sed 's/^|/+hood\//')" "hood"
}

_durploy__grab_ship_uid() {
	_durploy_grabuid_path=$1

	"$DURPLOY_URBIT_BIN" -d -L "$_durploy_grabuid_path" >/dev/null 2>&1
	_durploy_grabuid_suid="$(_durploy__send_dojo "$_durploy_grabuid_path" "our")"
	kill -9 "$(pgrep -f "urbit serf $(readlink -f "$_durploy_grabuid_path")")" >/dev/null 2>&1
	echo "$_durploy_grabuid_suid" | sed 's/^~//'
}

_durploy__check_desk_path() {
	_durploy_checkdp_path=$1
	_durploy_checkdp_uid=$2

	_durploy__invalid_ship "$_durploy_checkdp_uid" \
		&& _durploy__error "invalid ship name '$_durploy_checkdp_uid'"
	if [ ! -e "$_durploy_checkdp_path" ]; then
		mkdir -p "$(dirname "$_durploy_checkdp_path")" \
			|| _durploy__error "couldn't create directory at path '$_durploy_checkdp_path'"
	elif [ ! -d "$_durploy_checkdp_path" ]; then
		_durploy__error "invalid artifact exists at path '$_durploy_checkdp_path'"
	else
		_durploy_checkdp_rid="$(_durploy__grab_ship_uid "$_durploy_checkdp_path")"
		if [ "$_durploy_checkdp_rid" != "$_durploy_checkdp_uid" ]; then
			_durploy__error "invalid pier for '$_durploy_checkdp_uid' at '$_durploy_checkdp_path' (pier @p: '$_durploy_checkdp_rid')"
		fi
	fi
}

_durploy__check_ship_live() {
	pgrep -f "urbit serf $(readlink -f "$1")" | grep -q -v "grep"
}

_durploy__desk_install() {
	_durploy_install_desk=$1
	_durploy_install_from="$(readlink -f "$2")"
	_durploy_install_to="$(readlink -f "$3")"

	_durploy__send_hood "$(dirname "$_durploy_install_to")" "|new-desk %$_durploy_install_desk, =hard &"
	_durploy__send_hood "$(dirname "$_durploy_install_to")" "|mount %$_durploy_install_desk"

	rsync -rcuL "$_durploy_install_from/" "$_durploy_install_to/"

	_durploy__send_hood "$(dirname "$_durploy_install_to")" "|commit %$_durploy_install_desk"
	_durploy__send_hood "$(dirname "$_durploy_install_to")" "|install our %$_durploy_install_desk"
}

_durploy__desk_sync() {
	_durploy_sync_desk=$1
	_durploy_sync_from="$(readlink -f "$2")"
	_durploy_sync_to="$(readlink -f "$3")"
	_durploy_sync_rstrat=$4

	_durploy_sync_files=$(rsync -in -rcuL "$_durploy_sync_from/" "$_durploy_sync_to/" \
		| awk '{if ($0 == "") exit; else print $2;}'
	)
	# TODO: Read the content of `desk.bill`?
	_durploy_sync_srcapps=$(find -L "$_durploy_sync_from/app" -type f -name "*.hoon" \
		| sed -re 's?.*/([^/]+).hoon$?\1?g'
	)
	_durploy_sync_apps=$(echo "$_durploy_sync_files" \
		| grep -E '^app/.+' \
		| sed -re 's?.*/([^/]+).hoon$?\1?g'
	)
	_durploy_sync_surs=$(echo "$_durploy_sync_files" \
		| grep -E '^sur/.+' \
		| sed -re 's?.*/([^/]+).hoon$?\1?g'
	)

	if [ -n "$_durploy_sync_files" ]; then
		rsync -rcuL "$_durploy_sync_from/" "$_durploy_sync_to/"

		_durploy_sync_reloadapps=""
		for _durploy_sync_app in $_durploy_sync_srcapps; do
			_durploy_sync_doreload="false"
			case $_durploy_sync_rstrat in
				always) _durploy_sync_doreload="true" ;;
				appsur) echo "$_durploy_sync_apps $_durploy_sync_surs" \
					| grep -F -wq "$_durploy_sync_app" \
					&& _durploy_sync_doreload="true" ;;
				sur) echo "$_durploy_sync_surs" \
					| grep -F -wq "$_durploy_sync_app" \
					&& _durploy_sync_doreload="true" ;;
				never) _durploy_sync_doreload="false" ;;
			esac
			if [ "$_durploy_sync_doreload" = "true" ]; then
				_durploy_sync_reloadapps="$_durploy_sync_reloadapps $_durploy_sync_app"
			fi
		done

		for _durploy_sync_reloadapp in $_durploy_sync_reloadapps; do
			_durploy__send_hood "$(dirname "$_durploy_sync_to")" "|nuke %$_durploy_sync_reloadapp, =hard &"
		done
		_durploy__send_hood "$(dirname "$_durploy_sync_to")" "|commit %$_durploy_sync_desk"
		for _durploy_sync_reloadapp in $_durploy_sync_reloadapps; do
			_durploy__send_hood "$(dirname "$_durploy_sync_to")" "|revive %$_durploy_sync_reloadapp"
		done
	fi
}

## Sub-Commands ##

durploy__ship() {
	while : ; do case $1 in
		-h | --help) printf "%s\\n" "$DURPLOY_HELP_SHIP" && exit 1 ;;
		-u | --uid) durploy_ship_uid=$2 && shift 2 ;;
		-*) printf "invalid option: %s\\n" "$1" && exit 1 ;;
		*) break ;;
	esac done
	_durploy__invalid_pargs_atleast 1 "$@" && _durploy__info "$DURPLOY_HELP_SHIP"

	durploy_ship_base=$1; shift
	[ -z "$durploy_ship_uid" ] && durploy_ship_uid="zod"

	if [ "$durploy_command_usecwd" = "true" ]; then
		durploy_ship_path="$(cwd)/$durploy_ship_base"
	else
		durploy_ship_path="$DURPLOY_SHIP_DIR/$durploy_ship_base"
	fi
	# FIXME: Ideally should use important config vars instead of path to
	# identify the ship.
	durploy_bkup_path="$DURPLOY_BACKUP_DIR/$durploy_ship_path"

	if _durploy__check_ship_live "$durploy_ship_path"; then
		_durploy__info "urbit ship '$durploy_ship_base' is already running"
	else
		_durploy__check_desk_path "$durploy_ship_path" "$durploy_ship_uid"
		_durploy__check_desk_path "$durploy_bkup_path" "$durploy_ship_uid"

		# if the pier doesn't exist yet, try to create it
		if [ ! -e "$durploy_ship_path" ]; then
			# if the backup exists and is valid, then copy it to the new pier path
			if [ -d "$durploy_bkup_path" ] && "$DURPLOY_URBIT_BIN" -t -x -L "$durploy_bkup_path"; then
				cp -r "$durploy_bkup_path" "$durploy_ship_path"
			# otherwise, attempt to create a new pier for the ship
			elif ! "$DURPLOY_URBIT_BIN" -t -x -L -c "$durploy_ship_path" -F "$durploy_ship_uid"; then
				_durploy__error "couldn't create ship '$durploy_ship_uid' at '$durploy_ship_path'"
			fi
		# else, attempt to boot the urbit and immediately exit
		else
			if ! "$DURPLOY_URBIT_BIN" -t -x -L "$durploy_ship_path"; then
				_durploy__error "couldn't revive ship '$durploy_ship_uid' at '$durploy_ship_path'"
			fi
		fi

		# if the backup doesn't exist, copy the new pier into that path
		if [ -n "$durploy_bkup_path" ] && [ ! -e "$durploy_bkup_path" ]; then
			cp -r "$durploy_ship_path" "$durploy_bkup_path"
		fi

		"$DURPLOY_URBIT_BIN" -L "$durploy_ship_path"
	fi
}

durploy__desk() {
	while : ; do case $1 in
		-h | --help) printf "%s\\n" "$DURPLOY_HELP_DESK" && exit 1 ;;
		-w | --watch) durploy_desk_iswatching="true" && shift 1 ;;
		-r | --reset-strategy) durploy_desk_resetstrat=$2 && shift 2 ;;
		-*) printf "invalid option: %s\\n" "$1" && exit 1 ;;
		*) break ;;
	esac done
	_durploy__invalid_pargs_atleast 3 "$@" && _durploy__info "$DURPLOY_HELP_DESK"

	durploy_desk_name=$1; shift
	durploy_desk_codepath=$1; shift
	durploy_desk_shipbase=$1; shift
	[ -z "$durploy_desk_iswatching" ] && durploy_desk_iswatching="false"
	[ -z "$durploy_desk_resetstrat" ] && durploy_desk_resetstrat="never"

	if [ "$durploy_command_usecwd" = "true" ]; then
		durploy_desk_shippath="$(cwd)/$durploy_desk_shipbase"
	else
		durploy_desk_shippath="$DURPLOY_SHIP_DIR/$durploy_desk_shipbase"
	fi
	durploy_desk_shipcodepath="$durploy_desk_shippath/$durploy_desk_name"

	_durploy__invalid_desk "$durploy_desk_name" \
		&& _durploy__error "invalid desk name '$durploy_desk_name'"
	[ ! -d "$durploy_desk_codepath" ] \
		&& _durploy__error "invalid urbit code desk at '$durploy_desk_codepath'"
	[ ! -d "$durploy_desk_shippath" ] \
		&& _durploy__error "invalid urbit ship at '$durploy_desk_shippath'"
	! echo "$durploy_desk_resetstrat" | grep -q -E "$DURPLOY_RESET_STRATS_REGEX" \
		&& _durploy__error "invalid reset strategy '$durploy_desk_resetstrat'; try one of '$DURPLOY_RESET_STRATS'"

	if ! _durploy__check_ship_live "$durploy_desk_shippath"; then
		_durploy__error "must run ship to deploy desk; please run: durploy ship $durploy_desk_shipbase"
	fi

	if [ ! -d "$durploy_desk_shipcodepath" ]; then
		_durploy__desk_install \
			"$durploy_desk_name" \
			"$durploy_desk_codepath" \
			"$durploy_desk_shipcodepath"
	fi

	while : ; do
		_durploy__desk_sync \
			"$durploy_desk_name" \
			"$durploy_desk_codepath" \
			"$durploy_desk_shipcodepath" \
			"$durploy_desk_resetstrat"
		[ "$durploy_desk_iswatching" = "false" ] && break
		sleep 2
	done
}

## Main Command ##

durploy() {
	while : ; do case $1 in
		-h | --help) printf "%s\\n" "$DURPLOY_HELP_BASE" && exit 1 ;;
		-v | --version) printf "%s\\n" "$DURPLOY_VERSION" && exit 1 ;;
		-c | --cwd) durploy_command_usecwd="true" && shift 1 ;;
		-*) printf "invalid option: %s\\n" "$1" && exit 1 ;;
		*) break ;;
	esac done
	_durploy__invalid_pargs_atleast 1 "$@" && _durploy__info "$DURPLOY_HELP_BASE"

	durploy_command_name=$1; shift
	[ -z "$durploy_command_usecwd" ] && durploy_command_usecwd="false"

	if type "durploy__$durploy_command_name" >/dev/null 2>&1; then
		"durploy__$durploy_command_name" "$@"
	else
		_durploy__error "invalid command name '$durploy_command_name'"
	fi
}

# if the functions above are sourced into an interactive interpreter, the user can
# just call "durploy ship" or "durploy desk" with no further code needed.

# if invoked as a script rather than sourced, call function named on argv via the below;
# note that this must be the first operation other than a function definition
# for $_ to successfully distinguish between sourcing and invocation:
# [ ! "$_" -eq "$0" ] && return

durploy "$@"
