#!/bin/sh

# TODO: Add support for multiple ships to be synchronize targets for desk
# in a single command.
# TODO: Handle cases when 'urbit' is not installed on the host system
# (allow users to download the latest binary for their system, managed
# by the local config in e.g. ~/.local/share/durploy/binaries)

## Constants ##

DURPLOY_VERSION="0.0.7"
DURPLOY_HELP_FOOTER="
Report bugs to: ~sidnym-ladrut
durploy home page: <https://github.com/sidnym-ladrut/durploy>"
DURPLOY_HELP_BASE="usage: durploy [-v | --version] [-h | --help]
               [-b | --binary <bin-path>]
               <command> [<args>]
d(e)ploy ur(bit) ships and desks

Command options:
  ship: Generate and run Urbit ships
  desk: Deploy desk files to running Urbit ships
  nuke: Remove managed Urbit ships and/or backups

Flag arguments:
  -v, --version: Show the software version
  -h, --help: Show this help message
  -b, --binary: Set the Urbit binary to be used for deploying ships/desks
    (default: \$DURPLOY_URBIT_BIN)

Config options (via environment variables or sh config file):
  DURPLOY_CONFIG_FILE: Path to the config file (default: \$XDG_CONFIG_HOME/durploy/durployrc)
  DURPLOY_SHIP_DIR: Path for storing ship piers (default: \$XDG_CACHE_HOME/durploy/ships)
  DURPLOY_BACKUP_DIR: Path for storing ship backups (default: \$XDG_CACHE_HOME/durploy/backups)
  DURPLOY_CACHE_DIR: Path for storing cache files, e.g. git repos (default: \$XDG_CACHE_HOME/durploy/cache)
  DURPLOY_URBIT_BIN: Path to default Urbit binary (default: \$(which urbit))
$DURPLOY_HELP_FOOTER"
DURPLOY_HELP_SHIP="usage: durploy ship [-p | --patp <ship-patp>] [-n | --nuke <level>]
                      <ship-path> [<boot-script> ...]
Generate and run Urbit ships (w/ optional boot script(s))

Positional arguments:
  ship-path: The relative file path for the ship's pier (e.g. testing/zod)
  boot-script: The file path for the boot script (e.g. /path/to/init.sh)

Flag arguments:
  -p, --patp: The @p (i.e. Urbit ID) of the ship to be deployed at the given path
    (default: zod)
  -n, --nuke: Run nuke with given severity prior to deployment; one of:
    2: Nuke both pier and backup; start ship from a clean slate
    1: Nuke just the pier; allow the ship to boot from the backup if it exists
    0 (default): Don't nuke; run pier if it exists, or backup if that exists
$DURPLOY_HELP_FOOTER"
DURPLOY_HELP_DESK="usage: durploy desk [-w | --watch] [-r | --reset <strategy>]
                    <ship-path> <desk-name> <desk-path>
Deploy desk files to running Urbit ships

Positional arguments:
  ship-path: The relative file path for the ship's pier (e.g. testing/zod)
  desk-name: The name of the desk to deploy (e.g. my-desk)
  desk-path: The file path for the desk's source files (e.g. /path/to/my-desk)

Flag arguments:
  -w, --watch: Monitor <desk-path> for changes and deploy continuously
  -r, --reset: Strategy for resetting apps on a desk; one of:
    always: reset apps every time a file is changed
    appsur: only reset apps when their particular app/sur file changes
    sur: only reset apps when their particular sur file changes
    never (default): never reset apps; only copy files and '|commit'
$DURPLOY_HELP_FOOTER"
DURPLOY_HELP_NUKE="usage: durploy nuke [-l | --level <level>] <ship-path>
Remove previously deployed Urbit pier and its associated backup

Positional arguments:
  ship-path: The relative file path for the ship's pier (e.g. testing/zod)

Flag arguments:
  -l, --level: Run nuke with given severity level; one of:
    2 (default): Nuke both the pier and the backup
    1: Nuke just the pier (keep just the backup)
    0: Don't nuke (keep the pier and backup)
$DURPLOY_HELP_FOOTER"
DURPLOY_RESET_STRATS="always appsur sur never"
# shellcheck disable=SC2059,SC2086
DURPLOY_RESET_STRATS_REGEX=$(printf "(%s)|" $DURPLOY_RESET_STRATS \
	| sed 's/|$//' \
	| xargs printf "^(%s)$"
)

## Config Variables ##

DURPLOY_CONFIG_FILE="${DURPLOY_CONFIG_FILE:-${XDG_CONFIG_HOME:-~/.config}/durploy/durployrc}"
# shellcheck disable=SC1090
[ -f "$DURPLOY_CONFIG_FILE" ] && . "$DURPLOY_CONFIG_FILE"

DURPLOY_SHIP_DIR="${DURPLOY_SHIP_DIR:-${XDG_CACHE_HOME:-~/.cache}/durploy/ships}"
DURPLOY_BACKUP_DIR="${DURPLOY_BACKUP_DIR:-${XDG_CACHE_HOME:-~/.cache}/durploy/backups}"
DURPLOY_CACHE_DIR="${DURPLOY_CACHE_DIR:-${XDG_CACHE_HOME:-~/.cache}/durploy/cache}"
DURPLOY_URBIT_BIN="${DURPLOY_URBIT_BIN:-$(which urbit)}"

## Helper Functions ##

_durploy__info() { echo "[INFO]: $1" && exit 1; }
_durploy__error() { echo "[ERROR]: $1" && exit 1; }
_durploy__invalid_pargs_exact() { [ "$(($1+1))" != "$#" ]; }
_durploy__invalid_pargs_atleast() { [ "$(($1+1))" -gt "$#" ]; }
_durploy__remove() { echo "removing $1" && rm -rIv "$1"; }

_durploy__b__invalid_patp() { echo "(scan \"$2\" fed:ag)" | "$1" eval 2>&1 | grep -q "bail: %exit"; }
_durploy__b__invalid_desk() { echo "(scan \"$2\" sym)" | "$1" eval 2>&1 | grep -q "bail: %exit"; }
_durploy__b__hash_config() { sha256sum -b "$1" | awk '{print $1;}'; }

_durploy__p__send_dojo() {
	_durploy_senddojo_pier=$1
	_durploy_senddojo_cmddojo=$2
	_durploy_senddojo_cmdapp=$3

	_durploy_senddojo_shipport=$(awk '/loopback/ {print $1;}' < "$_durploy_senddojo_pier/.http.ports")
	_durploy_senddojo_cmdsource="{\"dojo\":\"$_durploy_senddojo_cmddojo\"}"
	if [ -z "$_durploy_senddojo_cmdapp" ] ; then
		_durploy_senddojo_cmdsink="{\"stdout\":null}"
	else
		_durploy_senddojo_cmdsink="{\"app\":\"$_durploy_senddojo_cmdapp\"}"
	fi

	curl -s --data \
		"{\"source\":$_durploy_senddojo_cmdsource,\"sink\":$_durploy_senddojo_cmdsink}" \
		"http://127.0.0.1:$_durploy_senddojo_shipport" \
		| xargs printf %s | sed 's/\\n/\n/g'
}
_durploy__p__send_hood() {
	_durploy__p__send_dojo "$1" "$(echo "$2" | sed 's/^|/+hood\//')" "hood"
}

_durploy__bp__start_ship() {
	"$1" -d -L "$2" >/dev/null 2>&1
}
_durploy__bp__stop_ship() {
	kill -9 "$(pgrep -f "$1 serf $(readlink -f "$2")")" >/dev/null 2>&1
}
_durploy__bp__islive_ship() {
	pgrep -f "$1 serf $(readlink -f "$2")" | grep -q -v "grep"
}

_durploy__bp__grab_ship_patp() {
	if _durploy__bp__islive_ship "$@"; then
		_durploy_grabpatp_live="true"
	else
		_durploy_grabpatp_live="false"
	fi

	[ "$_durploy_grabpatp_live" = "false" ] && _durploy__bp__start_ship "$@"
	_durploy_grabpatp_spatp="$(_durploy__p__send_dojo "$2" "our")"
	[ "$_durploy_grabpatp_live" = "false" ] && _durploy__bp__stop_ship "$@"

	echo "$_durploy_grabpatp_spatp" | sed 's/^~//'
}

_durploy__bp__check_pier_path() {
	_durploy_checkpier_bin=$1
	_durploy_checkpier_path=$2
	_durploy_checkpier_patp=$3

	_durploy__b__invalid_patp "$_durploy_checkpier_bin" "$_durploy_checkpier_patp" \
		&& _durploy__error "invalid ship name '$_durploy_checkpier_patp'"
	if [ ! -e "$_durploy_checkpier_path" ]; then
		mkdir -p "$(dirname "$_durploy_checkpier_path")" \
			|| _durploy__error "couldn't create directory at path '$_durploy_checkpier_path'"
	elif [ ! -d "$_durploy_checkpier_path" ]; then
		_durploy__error "invalid artifact exists at path '$_durploy_checkpier_path'"
	else
		_durploy_checkpier_rid="$(_durploy__bp__grab_ship_patp "$_durploy_checkpier_bin" "$_durploy_checkpier_path")"
		if [ "$_durploy_checkpier_rid" != "$_durploy_checkpier_patp" ]; then
			_durploy__error "bad @p '$_durploy_checkpier_patp' for '$_durploy_checkpier_path' (pier @p: '$_durploy_checkpier_rid')"
		fi
	fi
}

_durploy__p__desk_init() {
	_durploy_init_pier="$(readlink -f "$1")"
	_durploy_init_desk=$2
	_durploy__p__send_hood "$_durploy_init_pier" "|new-desk %$_durploy_init_desk, =hard &"
	_durploy__p__send_hood "$_durploy_init_pier" "|mount %$_durploy_init_desk"
}
_durploy__p__desk_cpdir() {
	_durploy_copydir_pier="$(readlink -f "$1")"
	_durploy_copydir_desk=$2
	_durploy_copydir_from="$(readlink -f "$3")"
	rsync -rcuL "$_durploy_copydir_from/" "$_durploy_copydir_pier/$_durploy_copydir_desk/"
}
_durploy__p__desk_cpgit() {
	_durploy_copygit_pier="$(readlink -f "$1")"; shift
	_durploy_copygit_desk=$1; shift
	_durploy_copygit_repo=$1; shift
	_durploy_copygit_hash=$1; shift

	_durploy_copygit_repopath="$DURPLOY_CACHE_DIR/$(echo "$_durploy_copygit_repo" | sed -re 's|.*/(.+)\.git|\1|g')"
	if [ ! -d "$_durploy_copygit_repopath" ]; then
		git clone "$_durploy_copygit_repo" "$_durploy_copygit_repopath"
	else
		# TODO: Verify that this is a git repository with the proper remote, i.e. "$_durploy_copygit_repo"
		:
	fi
	if [ -n "$_durploy_copygit_hash" ]; then
		# TODO: Checkout the specified version
		# git -C "$_durploy_copygit_repopath" checkout $(git describe --tags $(git rev-list --tags --max-count=1))
		:
	fi

	for _durploy_copygit_pair in "$@"; do
		_durploy_copygit_from=""
		_durploy_copygit_dest=""
		for _durploy_copygit_pairitem in $_durploy_copygit_pair; do
			[ -z "$_durploy_copygit_from" ] && _durploy_copygit_from="$_durploy_copygit_pairitem" && continue
			[ -z "$_durploy_copygit_dest" ] && _durploy_copygit_dest="$_durploy_copygit_pairitem" && continue
		done

		_durploy_copygit_frompath="$_durploy_copygit_repopath/$_durploy_copygit_from"
		_durploy_copygit_destpath="$_durploy_copygit_pier/$_durploy_copygit_desk/$_durploy_copygit_dest"
		rsync -rcuL "$_durploy_copygit_frompath" "$_durploy_copygit_destpath"
	done
}
_durploy__p__desk_inst() {
	_durploy_inst_pier="$(readlink -f "$1")"
	_durploy_inst_desk=$2
	_durploy__p__send_hood "$_durploy_inst_pier" "|commit %$_durploy_inst_desk"
	_durploy__p__send_hood "$_durploy_inst_pier" "|install our %$_durploy_inst_desk"
}

_durploy__p__desk_install() {
	_durploy_install_pier="$(readlink -f "$1")"
	_durploy_install_desk=$2
	_durploy_install_from="$(readlink -f "$3")"

	_durploy__p__desk_init "$_durploy_install_pier" "$_durploy_install_desk"
	_durploy__p__desk_cpdir "$_durploy_install_pier" "$_durploy_install_desk" "$_durploy_install_from"
	_durploy__p__desk_inst "$_durploy_install_pier" "$_durploy_install_desk"
}

_durploy__p__desk_sync() {
	_durploy_sync_pier="$(readlink -f "$1")"
	_durploy_sync_desk=$2
	_durploy_sync_from="$(readlink -f "$3")"
	_durploy_sync_rstrat=$4

	_durploy_sync_files=$(rsync -in -rcuL "$_durploy_sync_from/" "$_durploy_sync_pier/$_durploy_sync_desk/" \
		| awk '{if ($0 == "") exit; else print $2;}'
	)
	# TODO: Read the content of `desk.bill`?
	_durploy_sync_srcapps=$(find -L "$_durploy_sync_from/app" -type f -name "*.hoon" \
		| sed -re 's?.*/([^/]+).hoon$?\1?g'
	)
	_durploy_sync_apps=$(echo "$_durploy_sync_files" \
		| grep -E '^app/.+' \
		| sed -re 's?.*/([^/]+).hoon$?\1?g'
	)
	_durploy_sync_surs=$(echo "$_durploy_sync_files" \
		| grep -E '^sur/.+' \
		| sed -re 's?.*/([^/]+).hoon$?\1?g'
	)

	if [ -n "$_durploy_sync_files" ]; then
		rsync -rcuL "$_durploy_sync_from/" "$_durploy_sync_pier/$_durploy_sync_desk/"

		_durploy_sync_reloadapps=""
		for _durploy_sync_app in $_durploy_sync_srcapps; do
			_durploy_sync_doreload="false"
			case $_durploy_sync_rstrat in
				always) _durploy_sync_doreload="true" ;;
				appsur) echo "$_durploy_sync_apps $_durploy_sync_surs" \
					| grep -F -wq "$_durploy_sync_app" \
					&& _durploy_sync_doreload="true" ;;
				sur) echo "$_durploy_sync_surs" \
					| grep -F -wq "$_durploy_sync_app" \
					&& _durploy_sync_doreload="true" ;;
				never) _durploy_sync_doreload="false" ;;
			esac
			if [ "$_durploy_sync_doreload" = "true" ]; then
				_durploy_sync_reloadapps="$_durploy_sync_reloadapps $_durploy_sync_app"
			fi
		done

		for _durploy_sync_reloadapp in $_durploy_sync_reloadapps; do
			_durploy__p__send_hood "$_durploy_sync_pier" "|nuke %$_durploy_sync_reloadapp, =hard &"
		done
		_durploy__p__send_hood "$_durploy_sync_pier" "|commit %$_durploy_sync_desk"
		for _durploy_sync_reloadapp in $_durploy_sync_reloadapps; do
			_durploy__p__send_hood "$_durploy_sync_pier" "|revive %$_durploy_sync_reloadapp"
		done
	fi
}

## Sub-Commands ##

# NOTE: All subcommands take the `durploy` base command arguments as their first
# set of args, e.g.:
#
#   durploy__command /path/to/urbit/bin ...

durploy__ship() {
	durploy_ship_bin=$1; shift
	while : ; do case $1 in
		-h | --help) printf "%s\\n" "$DURPLOY_HELP_SHIP" && exit 1 ;;
		-p | --patp) durploy_ship_patp=$2 && shift 2 ;;
		-n | --nuke) durploy_ship_nukelevel=$2 && shift 2 ;;
		-*) printf "invalid option: %s\\n" "$1" && exit 1 ;;
		*) break ;;
	esac done
	_durploy__invalid_pargs_atleast 1 "$@" && _durploy__info "$DURPLOY_HELP_SHIP"

	durploy_ship_base=$1; shift
	[ -z "$durploy_ship_patp" ] && durploy_ship_patp="zod"
	[ -z "$durploy_ship_nukelevel" ] && durploy_ship_nukelevel="0"

	for _durploy_ship_script in "$@"; do
		_durploy_ship_scriptpath="$(readlink -f "$_durploy_ship_script")"
		[ ! -f "$_durploy_ship_scriptpath" ] && \
			_durploy__error "provided init script either doesn't exist or can't be run: '$_durploy_ship_script'"
	done
	durploy_ship_pier="$DURPLOY_SHIP_DIR/$durploy_ship_base"
	durploy_ship_bkup="$DURPLOY_BACKUP_DIR/$durploy_ship_patp-$(_durploy__b__hash_config "$durploy_ship_bin")"

	if _durploy__bp__islive_ship "$durploy_ship_bin" "$durploy_ship_pier"; then
		_durploy__info "urbit ship '$durploy_ship_base' is already running"
	else
		[ "$durploy_ship_nukelevel" -gt "0" ] && \
			durploy__nuke "$durploy_ship_bin" -l "$durploy_ship_nukelevel" "$durploy_ship_base"
		_durploy__bp__check_pier_path "$durploy_ship_bin" "$durploy_ship_pier" "$durploy_ship_patp"
		_durploy__bp__check_pier_path "$durploy_ship_bin" "$durploy_ship_bkup" "$durploy_ship_patp"

		# TODO: Allow users to discard bad backups when they're detected

		# if the pier doesn't exist yet, try to create it
		if [ ! -e "$durploy_ship_pier" ]; then
			durploy_ship_runcmds="true"
			# if the backup exists and is valid, then copy it to the new pier path
			if [ -d "$durploy_ship_bkup" ] && "$durploy_ship_bin" -t -x -L "$durploy_ship_bkup"; then
				cp -r "$durploy_ship_bkup" "$durploy_ship_pier"
			# otherwise, attempt to create a new pier for the ship
			elif "$durploy_ship_bin" -t -x -L -c "$durploy_ship_pier" -F "$durploy_ship_patp"; then
				[ ! -e "$durploy_ship_bkup" ] && cp -r "$durploy_ship_pier" "$durploy_ship_bkup"
			# if creating the new ship failed, then error out
			else
				_durploy__error "couldn't create ship '$durploy_ship_patp' at '$durploy_ship_pier'"
			fi
		# else, attempt to boot the urbit and immediately exit
		else
			durploy_ship_runcmds="false"
			if "$durploy_ship_bin" -t -x -L "$durploy_ship_pier"; then
				[ ! -e "$durploy_ship_bkup" ] && cp -r "$durploy_ship_pier" "$durploy_ship_bkup"
			else
				_durploy__error "couldn't revive ship '$durploy_ship_patp' at '$durploy_ship_pier'"
			fi
		fi

		if [ "$durploy_ship_runcmds" = "true" ] && [ "0" != "$#" ]; then
			_durploy__bp__start_ship "$durploy_ship_bin" "$durploy_ship_pier"
			for _durploy_ship_script in "$@"; do
				# shellcheck disable=SC1090
				. "$(readlink -f "$_durploy_ship_script")"
			done
			_durploy__bp__stop_ship "$durploy_ship_bin" "$durploy_ship_pier"
		fi

		"$durploy_ship_bin" -L "$durploy_ship_pier"
	fi
}

durploy__desk() {
	durploy_desk_bin=$1; shift
	while : ; do case $1 in
		-h | --help) printf "%s\\n" "$DURPLOY_HELP_DESK" && exit 1 ;;
		-w | --watch) durploy_desk_iswatching="true" && shift 1 ;;
		-r | --reset) durploy_desk_resetstrat=$2 && shift 2 ;;
		-*) printf "invalid option: %s\\n" "$1" && exit 1 ;;
		*) break ;;
	esac done
	_durploy__invalid_pargs_atleast 3 "$@" && _durploy__info "$DURPLOY_HELP_DESK"

	durploy_desk_shipbase=$1; shift
	durploy_desk_name=$1; shift
	durploy_desk_codepath=$1; shift
	[ -z "$durploy_desk_iswatching" ] && durploy_desk_iswatching="false"
	[ -z "$durploy_desk_resetstrat" ] && durploy_desk_resetstrat="never"
	durploy_desk_pier="$DURPLOY_SHIP_DIR/$durploy_desk_shipbase"

	_durploy__b__invalid_desk "$durploy_desk_bin" "$durploy_desk_name" \
		&& _durploy__error "invalid desk name '$durploy_desk_name'"
	[ ! -d "$durploy_desk_codepath" ] \
		&& _durploy__error "invalid urbit code desk at '$durploy_desk_codepath'"
	[ ! -d "$durploy_desk_pier" ] \
		&& _durploy__error "invalid urbit pier at '$durploy_desk_pier'"
	! echo "$durploy_desk_resetstrat" | grep -q -E "$DURPLOY_RESET_STRATS_REGEX" \
		&& _durploy__error "invalid reset strategy '$durploy_desk_resetstrat'; try one of '$DURPLOY_RESET_STRATS'"

	if ! _durploy__bp__islive_ship "$durploy_desk_bin" "$durploy_desk_pier"; then
		_durploy__error "must run ship to deploy desk; please run: durploy ship $durploy_desk_shipbase"
	fi

	if [ ! -d "$durploy_desk_pier/$durploy_desk_name" ]; then
		_durploy__p__desk_install \
			"$durploy_desk_pier" \
			"$durploy_desk_name" \
			"$durploy_desk_codepath"
	fi

	while : ; do
		_durploy__p__desk_sync \
			"$durploy_desk_pier" \
			"$durploy_desk_name" \
			"$durploy_desk_codepath" \
			"$durploy_desk_resetstrat"
		[ "$durploy_desk_iswatching" = "false" ] && break
		sleep 2
	done
}

durploy__nuke() {
	# TODO: Consider making this a more general command to clear out cache information
	# (e.g. not only ships and backups, but old Git libraries, binaries, etc.)
	durploy_nuke_bin=$1; shift
	while : ; do case $1 in
		-h | --help) printf "%s\\n" "$DURPLOY_HELP_NUKE" && exit 1 ;;
		-l | --level) durploy_nuke_level=$2 && shift 2 ;;
		-*) printf "invalid option: %s\\n" "$1" && exit 1 ;;
		*) break ;;
	esac done
	_durploy__invalid_pargs_exact 1 "$@" && _durploy__info "$DURPLOY_HELP_NUKE"

	durploy_nuke_base=$1; shift
	[ -z "$durploy_nuke_level" ] && durploy_nuke_level="2"

	durploy_nuke_pier="$DURPLOY_SHIP_DIR/$durploy_nuke_base"
	[ "$durploy_nuke_level" -gt "1" ] && \
		durploy_nuke_bkup="$DURPLOY_BACKUP_DIR/$(_durploy__bp__grab_ship_patp \
			"$durploy_nuke_bin" "$durploy_nuke_base")-$(_durploy__b__hash_config "$durploy_nuke_bin")"

	if _durploy__bp__islive_ship "$durploy_nuke_bin" "$durploy_nuke_pier"; then
		_durploy__error "cannot nuke running ship '$durploy_nuke_pier'"
	fi

	[ "$durploy_nuke_level" -gt "0" ] && _durploy__remove "$durploy_nuke_pier"
	[ "$durploy_nuke_level" -gt "1" ] && _durploy__remove "$durploy_nuke_bkup"
}

## Main Command ##

durploy() {
	while : ; do case $1 in
		-h | --help) printf "%s\\n" "$DURPLOY_HELP_BASE" && exit 1 ;;
		-v | --version) printf "%s\\n" "$DURPLOY_VERSION" && exit 1 ;;
		-b | --binary) durploy_command_binary=$2 && shift 2 ;;
		-*) printf "invalid option: %s\\n" "$1" && exit 1 ;;
		*) break ;;
	esac done
	_durploy__invalid_pargs_atleast 1 "$@" && _durploy__info "$DURPLOY_HELP_BASE"

	durploy_command_name=$1; shift
	[ -z "$durploy_command_binary" ] && durploy_command_binary="$DURPLOY_URBIT_BIN"
	durploy_command_binary="$(readlink -f "$durploy_command_binary")"

	if type "durploy__$durploy_command_name" >/dev/null 2>&1; then
		[ ! -x "$durploy_command_binary" ] && \
			_durploy__error "couldn't find default vere binary at path '$durploy_command_binary'"
		for _durploy_dir in "$DURPLOY_SHIP_DIR" "$DURPLOY_BACKUP_DIR" "$DURPLOY_CACHE_DIR"; do
			if [ ! -d "$_durploy_dir" ]; then
				mkdir -p "$_durploy_dir" || \
					_durploy__error "couldn't create config directory at path '$_durploy_dir'"
			fi
		done

		"durploy__$durploy_command_name" "$durploy_command_binary" "$@"
	else
		_durploy__error "invalid command name '$durploy_command_name'"
	fi
}

# if the functions above are sourced into an interactive interpreter, the user can
# just call "durploy ship" or "durploy desk" with no further code needed.

# if invoked as a script rather than sourced, call function named on argv via the below;
# note that this must be the first operation other than a function definition
# for $_ to successfully distinguish between sourcing and invocation:
# [ ! "$_" -eq "$0" ] && return

durploy "$@"
